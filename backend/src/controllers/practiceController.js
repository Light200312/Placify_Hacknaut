import PracticeQuestion from '../models/practiceQuestionModel.js';
import { callGeminiQuestionGenerator } from './aiController.js';

// --- Helper Functions ---

/**
 * Guesses difficulty from a descriptive round string.
 */
function mapRoundToDifficulty(roundStr) {
  if (!roundStr) return 'Medium';
  const lowerRound = roundStr.toLowerCase();

  if (
    lowerRound.includes('easy') ||
    lowerRound.includes('screening') ||
    lowerRound.includes('cognitive')
  )
    return 'Easy';

  if (
    lowerRound.includes('hard') ||
    lowerRound.includes('final') ||
    lowerRound.includes('system')
  )
    return 'Hard';

  if (
    lowerRound.includes('medium') ||
    lowerRound.includes('technical')
  )
    return 'Medium';

  return 'Medium'; // Default
}

// --- NEW HELPER FUNCTION ---
/**
 * Determines if a round is Aptitude, Coding, or System Design
 */
function getRoundType(roundStr) {
  const lowerRound = roundStr.toLowerCase();

  if (
    lowerRound.includes('numerical') ||
    lowerRound.includes('verbal') ||
    lowerRound.includes('reasoning') ||
    lowerRound.includes('cognitive') ||
    lowerRound.includes('aptitude') ||
    lowerRound.includes('psychometric') ||
    lowerRound.includes('behavioral') ||
    lowerRound.includes('foundation')
  ) {
    return 'Aptitude';
  }

  if (lowerRound.includes('system design')) {
    return 'System Design';
  }

  return 'Coding'; // Default
}

/**
 * Calculate estimated time for practicing questions
 */
function getEstimatedTime(questionCount, difficulty, roundStr) {
  const roundType = getRoundType(roundStr);

  let timePerQuestion;

  if (roundType === 'Aptitude') {
    timePerQuestion = 2; // minutes
  } else if (roundType === 'System Design') {
    timePerQuestion = 45; // minutes
  } else {
    const codingTimeMap = {
      Easy: 15,
      Medium: 30,
      Hard: 60,
    };
    timePerQuestion = codingTimeMap[difficulty] || 30;
  }

  const minutes = timePerQuestion * questionCount;
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;

  let formatted = '';
  if (hours > 0) {
    formatted += `${hours} hour${hours !== 1 ? 's' : ''} `;
  }
  if (remainingMinutes > 0) {
    formatted += `${remainingMinutes} minutes`;
  }
  if (formatted.trim() === '') {
    formatted = `${minutes} minutes`;
  }

  return {
    minutes,
    hours,
    formatted: formatted.trim(),
  };
}

/**
 * Helper function to parse strings like "45 Questions"
 */
const parseQuestionCount = (numQuestionsStr) => {
  if (!numQuestionsStr) return 5;
  const match = numQuestionsStr.match(/\d+/);
  return match ? parseInt(match[0], 10) : 5;
};

// --- Main Controller Function ---

/**
 * [GET] /api/leetcode/questions
 * Fetches practice questions.
 */
export const getPracticeQuestions = async (req, res) => {
  const { company, round } = req.query;
  const count = parseQuestionCount(req.query.count);

  if (!company || !round) {
    return res.status(400).json({ message: 'Company and round are required' });
  }

  const normalizedCompany = company.toLowerCase().trim();
  const normalizedRound = round.toLowerCase().trim();

  try {
    // 1. Cache check
    const cachedQuestions = await PracticeQuestion.findOne({
      company: normalizedCompany,
      round: normalizedRound,
    });

    if (cachedQuestions) {
      console.log(`‚úÖ CACHE HIT for: ${company} - ${round}`);

      const estimatedTime = getEstimatedTime(
        count,
        cachedQuestions.difficulty,
        normalizedRound
      );

      return res.json({
        success: true,
        message: 'Fetched from cache',
        company,
        round,
        difficulty: cachedQuestions.difficulty,
        count,
        problems: cachedQuestions.questions.slice(0, count),
        estimatedTime,
        source: 'cache-db',
      });
    }

    // 2. Cache miss ‚Üí Generate with AI
    console.log(`‚ö†Ô∏è CACHE MISS for: ${company} - ${round}. Calling Gemini...`);

    const difficulty = mapRoundToDifficulty(round);
    const generatedData = await callGeminiQuestionGenerator(
      company,
      round,
      difficulty,
      count
    );

    if (!generatedData || !generatedData.problems) {
      throw new Error('AI failed to generate questions.');
    }

    const estimatedTime = getEstimatedTime(count, difficulty, normalizedRound);

    // Save full question set
    const newQuestionSet = new PracticeQuestion({
      company: normalizedCompany,
      round: normalizedRound,
      difficulty,
      questions: generatedData.problems,
      estimatedTime,
    });

    await newQuestionSet.save();
    console.log(`üíæ CACHE SAVED for: ${company} - ${round}`);

    return res.json({
      success: true,
      message: 'Generated by AI and cached',
      company,
      round,
      difficulty,
      count: generatedData.problems.length,
      problems: generatedData.problems,
      estimatedTime,
      source: 'live-ai',
    });

  } catch (error) {
    // --- Race condition fix ---
    if (error.code === 11000) {
      console.log(
        `Race condition detected for: ${company} - ${round}. Another request saved first.`
      );

      try {
        const nowCached = await PracticeQuestion.findOne({
          company: normalizedCompany,
          round: normalizedRound,
        });

        if (nowCached) {
          const estimatedTime = getEstimatedTime(
            count,
            nowCached.difficulty,
            normalizedRound
          );

          return res.json({
            success: true,
            message: 'Fetched from cache (after race condition)',
            company,
            round,
            difficulty: nowCached.difficulty,
            count,
            problems: nowCached.questions.slice(0, count),
            estimatedTime,
            source: 'cache-db',
          });
        }

        throw new Error('Cache still empty after E11000 error.');
      } catch (retryError) {
        console.error('‚ùå Failed to recover:', retryError.message);
        return res.status(500).json({
          success: false,
          message: 'Failed to recover from race condition',
          error: retryError.message,
        });
      }
    }

    // Other errors
    console.error('‚ùå Error in getPracticeQuestions:', error.message);
    return res.status(500).json({
      success: false,
      message: 'Error fetching practice questions',
      error: error.message,
    });
  }
};
